import os
import json
import discord
from discord.ext import commands, tasks
from discord import app_commands, TextStyle, PartialEmoji
from discord.ui import Modal, TextInput, View, Button
import asyncio
import textwrap
import time
import datetime
from zoneinfo import ZoneInfo
import uuid
import aiofiles
import threading
from http.server import BaseHTTPRequestHandler, HTTPServer
from typing import Optional

# Configuration du port pour Render (ou autre h√©bergeur)
os.environ["PORT"] = "10000"

# ========================================
# üìÅ Chemins des fichiers persistants
# ========================================
DATA_FOLDER = "/data"
XP_FILE = os.path.join(DATA_FOLDER, "xp.json")
MSG_FILE = os.path.join(DATA_FOLDER, "messages_programmes.json")
DEFIS_FILE = os.path.join(DATA_FOLDER, "defis.json")
AUTO_DM_FILE = os.path.join(DATA_FOLDER, "auto_dm_configs.json")
POMODORO_CONFIG_FILE = os.path.join(DATA_FOLDER, "config_pomodoro.json")
GOALS_FILE = os.path.join(DATA_FOLDER, "objectifs.json")
SOS_CONFIG_FILE = os.path.join(DATA_FOLDER, "sos_config.json")
EVENEMENT_CONFIG_FILE = os.path.join(DATA_FOLDER, "evenement.json")
THEME_CONFIG_FILE = os.path.join(DATA_FOLDER, "themes.json")
MISSIONS_FILE = os.path.join(DATA_FOLDER, "missions_secretes.json")
CALENDRIER_FILE = os.path.join(DATA_FOLDER, "evenements_calendrier.json")
HELP_REQUEST_FILE = os.path.join(DATA_FOLDER, "help_requests.json")
REACTION_ROLE_FILE = os.path.join(DATA_FOLDER, "reaction_roles.json")
os.makedirs(DATA_FOLDER, exist_ok=True)

# ========================================
# Verrou global d'acc√®s asynchrone aux fichiers
# ========================================
file_lock = asyncio.Lock()

# ========================================
# Fonctions asynchrones de persistance
# ========================================
async def charger_json_async(path: str):
    async with file_lock:
        if not os.path.exists(path):
            async with aiofiles.open(path, "w", encoding="utf-8") as f:
                await f.write(json.dumps({}))
        async with aiofiles.open(path, "r", encoding="utf-8") as f:
            content = await f.read()
            try:
                return json.loads(content)
            except json.JSONDecodeError:
                return {}

async def sauvegarder_json_async(path: str, data):
    async with file_lock:
        async with aiofiles.open(path, "w", encoding="utf-8") as f:
            await f.write(json.dumps(data, indent=4))

# ========================================
# Utilitaire pour standardiser un emoji
# ========================================
def get_emoji_key(emoji_input) -> str:
    try:
        if isinstance(emoji_input, PartialEmoji):
            pe = emoji_input
        else:
            pe = PartialEmoji.from_str(str(emoji_input))
        if pe.is_custom_emoji():
            return f"<:{pe.name}:{pe.id}>"
        return str(pe)
    except Exception:
        return str(emoji_input)

# ========================================
# Variables globales
# ========================================
xp_data = {}
messages_programmes = {}
defis_data = {}
config_pomodoro = {}
objectifs_data = {}
# Pour g√©rer les demandes d'aide
categories_aide = {}

# ========================================
# Configuration des intents
# ========================================
intents = discord.Intents.default()
intents.message_content = True
intents.members = True
intents.guilds = True
intents.reactions = True
intents.voice_states = True

# ========================================
# Classe principale du bot
# ========================================
class MyBot(commands.Bot):
    def __init__(self):
        super().__init__(command_prefix="!", intents=intents)
        self.reaction_roles = {}  # Mapping message_id -> {emoji_key: role_id}
        self.vocal_start_times = {}  # {user_id: timestamp}
        self.xp_config = {
            "xp_per_message": 10,
            "xp_per_minute_vocal": 5,
            "multipliers": {},  
            "level_roles": {},  
            "announcement_channel": None,
            "announcement_message": "üéâ {mention} a atteint {xp} XP !",
            "xp_command_channel": None,
            "xp_command_min_xp": 0,
            "badges": {},
            "titres": {},
            "goals_channel": None
        }
        self.recap_config = {
            "channel_id": None,
            "role_id": None
        }
        self.weekly_stats = {}  # {user_id: {"messages": int, "vocal": int (secondes)}}
        self.sos_receivers = []
        self.missions_secretes = {}
        self.evenement_config = {}
        self.theme_config = {}
        self.evenements_calendrier = {}
        self.temp_data = {}  # Pour stocker temporairement des donn√©es (ex: reaction_role)

    async def setup_hook(self):
        try:
            synced = await self.tree.sync()
            print(f"üåê {len(synced)} commandes slash synchronis√©es")
            if not check_programmed_messages.is_running():
                check_programmed_messages.start()
                print("‚úÖ Boucle des messages programm√©s d√©marr√©e")
            if not recap_hebdo_task.is_running():
                recap_hebdo_task.start()
                print("üïí T√¢che r√©cap hebdomadaire d√©marr√©e")
            if not weekly_stats_task.is_running():
                weekly_stats_task.start()
                print("üìä T√¢che statistiques hebdomadaires d√©marr√©e")
        except Exception as e:
            print(f"‚ùå Erreur dans setup_hook: {e}")

bot = MyBot()
tree = bot.tree

# ========================================
# Gestion des messages (XP & mod√©ration)
# ========================================
@bot.event
async def on_message(message: discord.Message):
    if message.author.bot:
        return
    # Filtrage des mots interdits
    if not message.author.guild_permissions.administrator:
        banned_words = {"merde", "putain", "con", "connard", "salop", "encul√©", "nique ta m√®re"}
        contenu_lower = message.content.lower()
        for banned in banned_words:
            if banned in contenu_lower:
                try:
                    await message.delete()
                    try:
                        await message.author.send("Ton message a √©t√© supprim√© pour propos interdits.")
                    except Exception as dm_err:
                        print(f"Erreur en DM √† {message.author}: {dm_err}")
                except Exception as del_err:
                    print(f"Erreur lors de la suppression du message: {del_err}")
                return
    # Attribution XP
    uid = str(message.author.id)
    bot.weekly_stats.setdefault(uid, {"messages": 0, "vocal": 0})
    bot.weekly_stats[uid]["messages"] += 1
    xp_val = bot.xp_config["xp_per_message"]
    multiplier = bot.xp_config["multipliers"].get(str(message.channel.id), 1.0)
    total_xp = int(xp_val * multiplier)
    current_xp = await add_xp(message.author.id, total_xp)
    for seuil, role_id in bot.xp_config["level_roles"].items():
        if current_xp >= int(seuil):
            role = message.guild.get_role(int(role_id))
            if role and role not in message.author.roles:
                try:
                    await message.author.add_roles(role, reason="Palier XP atteint")
                    if bot.xp_config["announcement_channel"]:
                        ann_chan = bot.get_channel(int(bot.xp_config["announcement_channel"]))
                        if ann_chan:
                            txt = bot.xp_config["announcement_message"].replace("{mention}", message.author.mention).replace("{xp}", str(current_xp))
                            await ann_chan.send(txt)
                except Exception as e:
                    print(f"‚ùå Erreur attribution r√¥le XP: {e}")
    await bot.process_commands(message)

# ========================================
# Gestion du temps vocal
# ========================================
@bot.event
async def on_voice_state_update(member: discord.Member, before: discord.VoiceState, after: discord.VoiceState):
    if not before.channel and after.channel:
        bot.vocal_start_times[member.id] = time.time()
    elif before.channel and not after.channel:
        start = bot.vocal_start_times.pop(member.id, None)
        if start:
            duration = int((time.time() - start) / 60)
            multiplier = bot.xp_config["multipliers"].get(str(before.channel.id), 1.0)
            gained = int(duration * bot.xp_config["xp_per_minute_vocal"] * multiplier)
            current_xp = await add_xp(member.id, gained)
            uid = str(member.id)
            bot.weekly_stats.setdefault(uid, {"messages": 0, "vocal": 0})
            bot.weekly_stats[uid]["vocal"] += duration * 60
            for seuil, role_id in bot.xp_config["level_roles"].items():
                if current_xp >= int(seuil):
                    role = member.guild.get_role(int(role_id))
                    if role and role not in member.roles:
                        try:
                            await member.add_roles(role, reason="XP vocal atteint")
                            if bot.xp_config["announcement_channel"]:
                                ann_chan = bot.get_channel(int(bot.xp_config["announcement_channel"]))
                                if ann_chan:
                                    txt = bot.xp_config["announcement_message"].replace("{mention}", member.mention).replace("{xp}", str(current_xp))
                                    await ann_chan.send(txt)
                        except Exception as e:
                            print(f"‚ùå Erreur attribution r√¥le vocal: {e}")

# ========================================
# Fonctions XP
# ========================================
async def add_xp(user_id, amount):
    uid = str(user_id)
    current = xp_data.get(uid, 0)
    new_total = current + amount
    xp_data[uid] = new_total
    await sauvegarder_json_async(XP_FILE, xp_data)
    return new_total

def get_xp(user_id):
    return xp_data.get(str(user_id), 0)

# ========================================
# T√¢che de messages programm√©s & d√©fis
# ========================================
@tasks.loop(seconds=30)
async def check_programmed_messages():
    try:
        if not bot.is_ready():
            print("‚è≥ Bot pas encore pr√™t...")
            return
        now = datetime.datetime.now(ZoneInfo("Europe/Paris"))
        messages_modifies = False
        for msg_id, msg in list(messages_programmes.items()):
            try:
                msg_time = datetime.datetime.strptime(msg["next"], "%d/%m/%Y %H:%M")
                msg_time = msg_time.replace(tzinfo=ZoneInfo("Europe/Paris"))
            except ValueError as ve:
                print(f"‚ùå Format invalide pour {msg_id}: {ve}")
                continue
            if now >= msg_time:
                channel = bot.get_channel(int(msg["channel_id"]))
                if channel:
                    if msg["type"] in ["once", "daily", "weekly"]:
                        await channel.send(textwrap.dedent(msg["message"]))
                    elif msg["type"] == "weekly_challenge":
                        sent_msg = await channel.send(textwrap.dedent(msg["message"]))
                        await sent_msg.add_reaction("‚úÖ")
                        end_ts = time.time() + float(msg["duration_hours"]) * 3600
                        defis_data[str(sent_msg.id)] = {
                            "channel_id": channel.id,
                            "role_id": msg["role_id"],
                            "end_timestamp": end_ts
                        }
                        await sauvegarder_json_async(DEFIS_FILE, defis_data)
                        asyncio.create_task(retirer_role_apres_defi(channel.guild, sent_msg.id, channel.guild.get_role(int(msg["role_id"]))))
                    # Mise √† jour du prochain envoi selon le type
                    if msg["type"] == "once":
                        del messages_programmes[msg_id]
                        messages_modifies = True
                    elif msg["type"] == "daily":
                        while now >= msg_time:
                            msg_time += datetime.timedelta(days=1)
                        messages_programmes[msg_id]["next"] = msg_time.strftime("%d/%m/%Y %H:%M")
                        messages_modifies = True
                    elif msg["type"] in ["weekly", "weekly_challenge"]:
                        while now >= msg_time:
                            msg_time += datetime.timedelta(weeks=1)
                        messages_programmes[msg_id]["next"] = msg_time.strftime("%d/%m/%Y %H:%M")
                        messages_modifies = True
                else:
                    print(f"‚ö†Ô∏è Salon introuvable pour {msg_id}")
        if messages_modifies:
            await sauvegarder_json_async(MSG_FILE, messages_programmes)
    except Exception as e:
        print(f"‚ùå Erreur dans check_programmed_messages: {e}")

# ========================================
# Commandes XP & Leaderboard (slash)
# ========================================
@tree.command(name="xp", description="Affiche ton XP")
async def xp(interaction: discord.Interaction):
    config = bot.xp_config
    if config["xp_command_channel"] and interaction.channel.id != int(config["xp_command_channel"]):
        await interaction.response.send_message("‚ùå Commande non autoris√©e ici.", ephemeral=True)
        return
    user_xp = get_xp(interaction.user.id)
    if user_xp < config["xp_command_min_xp"]:
        await interaction.response.send_message("‚ùå XP insuffisant.", ephemeral=True)
        return
    badge = ""
    for seuil, b in sorted(config["badges"].items(), key=lambda x: int(x[0]), reverse=True):
        if user_xp >= int(seuil):
            badge = b
            break
    titre = ""
    for seuil, t in sorted(config["titres"].items(), key=lambda x: int(x[0]), reverse=True):
        if user_xp >= int(seuil):
            titre = t
            break
    texte = textwrap.dedent(f"""
        üîπ {interaction.user.mention}, tu as **{user_xp} XP**.
        {"üèÖ Badge : **" + badge + "**" if badge else ""}
        {"üìõ Titre : **" + titre + "**" if titre else ""}
    """)
    await interaction.response.send_message(texte.strip(), ephemeral=True)

@tree.command(name="leaderboard", description="Affiche le top 10 des membres par XP")
async def leaderboard(interaction: discord.Interaction):
    config = bot.xp_config
    if config["xp_command_channel"] and interaction.channel.id != int(config["xp_command_channel"]):
        await interaction.response.send_message("‚ùå Commande non autoris√©e ici.", ephemeral=True)
        return
    classement = sorted(xp_data.items(), key=lambda x: x[1], reverse=True)[:10]
    lignes = []
    for i, (uid, xp_val) in enumerate(classement):
        member = interaction.guild.get_member(int(uid))
        nom = member.display_name if member else f"Utilisateur {uid}"
        lignes.append(f"{i+1}. {nom} ‚Äî {xp_val} XP")
    txt = "üèÜ **Top 10 XP :**\n" + "\n".join(lignes) if lignes else "Aucun XP enregistr√©."
    await interaction.response.send_message(txt, ephemeral=True)

# ------------------------------------------
# Commandes XP ADMIN
# ------------------------------------------
@tree.command(name="add_xp", description="Ajoute de l'XP √† un membre (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def add_xp_cmd(interaction: discord.Interaction, member: discord.Member, amount: int):
    new_total = await add_xp(member.id, amount)
    await interaction.response.send_message(f"‚úÖ {amount} XP ajout√©s √† {member.mention}\nüîπ Total : **{new_total} XP**", ephemeral=True)

@tree.command(name="set_xp_config", description="Modifie l'XP par message et en vocal (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def set_xp_config(interaction: discord.Interaction, xp_per_message: int, xp_per_minute_vocal: int):
    bot.xp_config["xp_per_message"] = xp_per_message
    bot.xp_config["xp_per_minute_vocal"] = xp_per_minute_vocal
    await interaction.response.send_message(f"‚úÖ XP mis √† jour : {xp_per_message} xp/msg, {xp_per_minute_vocal} xp/min vocal", ephemeral=True)

@tree.command(name="set_xp_role", description="D√©finit un r√¥le √† d√©bloquer par XP (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def set_xp_role(interaction: discord.Interaction, xp: int, role: discord.Role):
    bot.xp_config["level_roles"][str(xp)] = role.id
    await interaction.response.send_message(f"‚úÖ Le r√¥le **{role.name}** sera attribu√© d√®s {xp} XP.", ephemeral=True)

@tree.command(name="set_xp_boost", description="Ajoute un multiplicateur d'XP √† un salon (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def set_xp_boost(interaction: discord.Interaction, channel: discord.TextChannel, multiplier: float):
    bot.xp_config["multipliers"][str(channel.id)] = multiplier
    await interaction.response.send_message(f"‚úÖ Multiplicateur x{multiplier} appliqu√© √† {channel.mention}.", ephemeral=True)

@tree.command(name="set_salon_annonce", description="D√©finit le salon des annonces de niveau (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def set_salon_annonce(interaction: discord.Interaction, channel: discord.TextChannel):
    bot.xp_config["announcement_channel"] = str(channel.id)
    await interaction.response.send_message(f"‚úÖ Annonces de niveau envoy√©es dans {channel.mention}.", ephemeral=True)

@tree.command(name="set_message_annonce", description="Modifie le message d‚Äôannonce (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def set_message_annonce(interaction: discord.Interaction, message: str):
    bot.xp_config["announcement_message"] = message
    preview = message.replace("{mention}", interaction.user.mention).replace("{xp}", "1234")
    await interaction.response.send_message(f"‚úÖ Message mis √† jour !\n\nüí¨ Aper√ßu:\n{preview}", ephemeral=True)

@tree.command(name="set_channel_xp", description="D√©finit le salon o√π /xp et /leaderboard sont utilisables (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def set_channel_xp(interaction: discord.Interaction, channel: discord.TextChannel):
    bot.xp_config["xp_command_channel"] = str(channel.id)
    await interaction.response.send_message(f"‚úÖ Commandes XP limit√©es √† {channel.mention}.", ephemeral=True)

@tree.command(name="set_minimum_xp", description="D√©finit le XP minimum pour /xp (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def set_minimum_xp(interaction: discord.Interaction, min_xp: int):
    bot.xp_config["xp_command_min_xp"] = min_xp
    await interaction.response.send_message(f"‚úÖ Minimum requis: {min_xp} XP.", ephemeral=True)

@tree.command(name="ajouter_badge", description="Ajoute un badge d√©bloqu√© par XP (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def ajouter_badge(interaction: discord.Interaction, xp: int, badge: str):
    bot.xp_config["badges"][str(xp)] = badge
    await interaction.response.send_message(f"‚úÖ Badge '{badge}' ajout√© d√®s {xp} XP.", ephemeral=True)

@tree.command(name="ajouter_titre", description="Ajoute un titre d√©bloqu√© par XP (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def ajouter_titre(interaction: discord.Interaction, xp: int, titre: str):
    bot.xp_config["titres"][str(xp)] = titre
    await interaction.response.send_message(f"‚úÖ Titre '{titre}' ajout√© d√®s {xp} XP.", ephemeral=True)

# ------------------------------------------
# Cr√©ation rapide de salons, r√¥les et cat√©gories
# ------------------------------------------
@tree.command(name="creer_salon", description="Cr√©e un ou plusieurs salons dans une cat√©gorie (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def creer_salon(interaction: discord.Interaction, noms: str, categorie: discord.CategoryChannel, type: str):
    noms_list = [n.strip() for n in noms.split(",") if n.strip()]
    if not noms_list:
        await interaction.response.send_message("‚ùå Aucun nom fourni.", ephemeral=True)
        return
    created_channels = []
    for nom in noms_list:
        try:
            if type.lower() == "text":
                channel = await interaction.guild.create_text_channel(name=nom, category=categorie)
            elif type.lower() == "voice":
                channel = await interaction.guild.create_voice_channel(name=nom, category=categorie)
            else:
                await interaction.response.send_message("‚ùå Type invalide (text ou voice).", ephemeral=True)
                return
            created_channels.append(channel.mention)
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Erreur cr√©ation salon {nom}: {e}", ephemeral=True)
            return
    msg = f"‚úÖ Salon{'s' if len(created_channels) > 1 else ''} cr√©√©{'s' if len(created_channels) > 1 else ''} : " + ", ".join(created_channels)
    await interaction.response.send_message(msg, ephemeral=True)

@tree.command(name="creer_role", description="Cr√©e un ou plusieurs r√¥les (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def creer_role(interaction: discord.Interaction, noms: str):
    noms_list = [n.strip() for n in noms.split(",") if n.strip()]
    if not noms_list:
        await interaction.response.send_message("‚ùå Aucun nom fourni.", ephemeral=True)
        return
    created_roles = []
    for nom in noms_list:
        try:
            role = await interaction.guild.create_role(name=nom)
            created_roles.append(role.name)
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Erreur cr√©ation r√¥le {nom}: {e}", ephemeral=True)
            return
    msg = f"‚úÖ R√¥le{'s' if len(created_roles) > 1 else ''} cr√©√©{'s' if len(created_roles) > 1 else ''} : " + ", ".join(created_roles)
    await interaction.response.send_message(msg, ephemeral=True)

@tree.command(name="creer_categorie_privee", description="Cr√©e une cat√©gorie priv√©e accessible √† un r√¥le (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def creer_categorie_privee(interaction: discord.Interaction, nom: str, role: discord.Role):
    try:
        overwrites = {
            interaction.guild.default_role: discord.PermissionOverwrite(view_channel=False),
            role: discord.PermissionOverwrite(view_channel=True)
        }
        new_cat = await interaction.guild.create_category(name=nom, overwrites=overwrites)
        await interaction.response.send_message(f"‚úÖ Cat√©gorie priv√©e **{new_cat.name}** cr√©√©e pour {role.name}.", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Erreur cr√©ation cat√©gorie: {e}", ephemeral=True)

# ------------------------------------------
# Messages programm√©s & D√©fis
# ------------------------------------------
class ProgrammerMessageModal(Modal, title="üóìÔ∏è Programmer un message"):
    def __init__(self, salon: discord.TextChannel, type_message: str, date_heure: str):
        super().__init__(timeout=None)
        self.salon = salon
        self.msg_type = type_message  # "once", "daily", "weekly", "weekly_challenge"
        self.date_heure = date_heure
        self.contenu = TextInput(
            label="Contenu du message",
            style=TextStyle.paragraph,
            placeholder="Tapez le message complet",
            required=True,
            max_length=2000
        )
        self.add_item(self.contenu)
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        texte = textwrap.dedent(self.contenu.value)
        if len(texte) > 2000:
            await interaction.followup.send("‚ùå Message trop long.", ephemeral=True)
            return
        msg_id = str(uuid.uuid4())
        messages_programmes[msg_id] = {
            "channel_id": str(self.salon.id),
            "message": texte,
            "type": self.msg_type,
            "next": self.date_heure
        }
        await sauvegarder_json_async(MSG_FILE, messages_programmes)
        await interaction.followup.send(f"‚úÖ Message programm√© dans {self.salon.mention} ({self.msg_type}) pour {self.date_heure}.", ephemeral=True)

@tree.command(name="programmer_message", description="Planifie un message automatique (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def programmer_message(interaction: discord.Interaction, salon: discord.TextChannel, type: str, date_heure: str):
    valid_types = ["once", "daily", "weekly", "weekly_challenge"]
    if type.lower() not in valid_types:
        await interaction.response.send_message("‚ùå Type invalide.", ephemeral=True)
        return
    try:
        datetime.datetime.strptime(date_heure, "%d/%m/%Y %H:%M")
    except ValueError:
        await interaction.response.send_message("‚ùå Format date invalide.", ephemeral=True)
        return
    try:
        await interaction.response.send_modal(ProgrammerMessageModal(salon, type.lower(), date_heure))
    except Exception as e:
        await interaction.followup.send(f"‚ùå Erreur modal: {e}", ephemeral=True)

@tree.command(name="supprimer_message_programm√©", description="Supprime un message programm√© (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def supprimer_message_programme(interaction: discord.Interaction, message_id: str):
    if message_id in messages_programmes:
        del messages_programmes[message_id]
        await sauvegarder_json_async(MSG_FILE, messages_programmes)
        await interaction.response.send_message("‚úÖ Message programm√© supprim√©.", ephemeral=True)
    else:
        await interaction.response.send_message("‚ùå ID non trouv√©.", ephemeral=True)

@tree.command(name="messages_programm√©s", description="Liste les messages programm√©s (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def messages_programm√©s_cmd(interaction: discord.Interaction):
    if not messages_programmes:
        await interaction.response.send_message("Aucun message programm√©.", ephemeral=True)
        return
    txt = "**üóìÔ∏è Messages programm√©s :**\n"
    for mid, msg in messages_programmes.items():
        txt += f"üÜî `{mid}` ‚Äî <#{msg['channel_id']}> ‚Äî {msg['next']} ‚Äî {msg['type']}\n"
    await interaction.response.send_message(txt.strip(), ephemeral=True)

class ModifierMessageModal(Modal, title="‚úèÔ∏è Modifier un message"):
    def __init__(self, message_id: str):
        super().__init__(timeout=None)
        self.message_id = message_id
        self.nouveau_msg = TextInput(
            label="Nouveau message",
            style=TextStyle.paragraph,
            placeholder="Tapez le nouveau message",
            required=True,
            max_length=2000
        )
        self.add_item(self.nouveau_msg)
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        if self.message_id in messages_programmes:
            messages_programmes[self.message_id]["message"] = textwrap.dedent(self.nouveau_msg.value)
            await sauvegarder_json_async(MSG_FILE, messages_programmes)
            await interaction.followup.send("‚úÖ Message modifi√©.", ephemeral=True)
        else:
            await interaction.followup.send("‚ùå ID introuvable.", ephemeral=True)

@tree.command(name="modifier_message_programm√©", description="Modifie un message programm√© (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def modifier_message_programme(interaction: discord.Interaction, message_id: str):
    if message_id in messages_programmes:
        await interaction.response.send_modal(ModifierMessageModal(message_id))
    else:
        await interaction.response.send_message("‚ùå ID non trouv√©.", ephemeral=True)

# ------------------------------------------
# Attribution de r√¥les via r√©actions
# ------------------------------------------
class RoleReactionModal(Modal, title="‚úçÔ∏è Message avec r√©action"):
    def __init__(self, emoji: str, role: discord.Role, salon: discord.TextChannel):
        super().__init__(timeout=None)
        try:
            self.emoji = PartialEmoji.from_str(emoji)
            self.emoji_key = get_emoji_key(self.emoji)
        except Exception as e:
            raise ValueError(f"Emoji invalide: {emoji}") from e
        self.role = role
        self.salon = salon
        self.contenu = TextInput(
            label="Texte du message",
            style=TextStyle.paragraph,
            placeholder="Tapez le message",
            required=True,
            max_length=2000
        )
        self.add_item(self.contenu)
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        try:
            msg_envoye = await self.salon.send(textwrap.dedent(self.contenu.value))
            await msg_envoye.add_reaction(self.emoji)
            bot.reaction_roles[str(msg_envoye.id)] = {self.emoji_key: self.role.id}
            await sauvegarder_json_async(REACTION_ROLE_FILE, bot.reaction_roles)
            await interaction.followup.send(f"‚úÖ Message envoy√© dans {self.salon.mention}", ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"‚ùå Erreur: {e}", ephemeral=True)

@tree.command(name="ajout_reaction_id", description="Ajoute une r√©action √† un message existant (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def ajout_reaction_id(interaction: discord.Interaction, role: discord.Role, emoji: str, message_id: str):
    try:
        mid = int(message_id)
        msg = await interaction.channel.fetch_message(mid)
        await msg.add_reaction(emoji)
        key = get_emoji_key(emoji)
        bot.reaction_roles.setdefault(str(mid), {})[key] = role.id
        await sauvegarder_json_async(REACTION_ROLE_FILE, bot.reaction_roles)
        await interaction.response.send_message(f"‚úÖ R√©action {emoji} ajout√©e au message {message_id} pour le r√¥le {role.name}.", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)

@bot.event
async def on_raw_reaction_add(payload: discord.RawReactionActionEvent):
    if payload.user_id == bot.user.id:
        return
    try:
        guild = bot.get_guild(payload.guild_id)
        if not guild: return
        member = guild.get_member(payload.user_id)
        if not member: return
        key = get_emoji_key(payload.emoji)
        data = bot.reaction_roles.get(str(payload.message_id))
        if not data: return
        role_id = data.get(key)
        if not role_id: return
        role = guild.get_role(int(role_id))
        if role and role not in member.roles:
            try:
                await member.add_roles(role, reason="R√©action ajout√©e")
            except Exception as e:
                print(f"‚ùå Erreur ajout r√¥le {role.name} pour {member.display_name}: {e}")
    except Exception as e:
        print(f"‚ùå Erreur dans on_raw_reaction_add: {e}")

@bot.event
async def on_raw_reaction_remove(payload: discord.RawReactionActionEvent):
    if payload.user_id == bot.user.id:
        return
    try:
        guild = bot.get_guild(payload.guild_id)
        if not guild: return
        member = guild.get_member(payload.user_id)
        if not member: return
        key = get_emoji_key(payload.emoji)
        data = bot.reaction_roles.get(str(payload.message_id))
        if not data: return
        role_id = data.get(key)
        if not role_id: return
        role = guild.get_role(int(role_id))
        if role and role in member.roles:
            try:
                await member.remove_roles(role, reason="R√©action retir√©e")
            except Exception as e:
                print(f"‚ùå Erreur retrait r√¥le {role.name} pour {member.display_name}: {e}")
    except Exception as e:
        print(f"‚ùå Erreur dans on_raw_reaction_remove: {e}")

# ------------------------------------------
# D√©fi hebdomadaire et r√©current
# ------------------------------------------
class DefiModal(Modal, title="üî• D√©fi de la semaine"):
    def __init__(self, salon: discord.TextChannel, role: discord.Role, duree_heures: int):
        super().__init__(timeout=None)
        self.salon = salon
        self.role = role
        self.duree = duree_heures
        self.message = TextInput(
            label="Message du d√©fi",
            style=TextStyle.paragraph,
            placeholder="D√©crivez votre d√©fi ici",
            required=True,
            max_length=2000
        )
        self.add_item(self.message)
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        try:
            msg = await self.salon.send(textwrap.dedent(self.message.value))
            await msg.add_reaction("‚úÖ")
            end_ts = time.time() + self.duree * 3600
            defis_data[str(msg.id)] = {"channel_id": self.salon.id, "role_id": self.role.id, "end_timestamp": end_ts}
            await sauvegarder_json_async(DEFIS_FILE, defis_data)
            asyncio.create_task(retirer_role_apres_defi(interaction.guild, msg.id, self.role))
            await interaction.followup.send(f"‚úÖ D√©fi lanc√© dans {self.salon.mention} pour {self.duree}h.", ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"‚ùå Erreur lancement d√©fi: {e}", ephemeral=True)

async def retirer_role_apres_defi(guild: discord.Guild, message_id: int, role: discord.Role):
    try:
        data = defis_data.get(str(message_id))
        if not data:
            print(f"‚ö†Ô∏è Pas de donn√©es pour le d√©fi {message_id}")
            return
        await asyncio.sleep(max(0, data["end_timestamp"] - time.time()))
        for member in role.members:
            try:
                await member.remove_roles(role, reason="Fin d√©fi hebdomadaire")
            except Exception as e:
                print(f"‚ùå Erreur retrait r√¥le pour {member.display_name}: {e}")
        del defis_data[str(message_id)]
        await sauvegarder_json_async(DEFIS_FILE, defis_data)
        print(f"‚úÖ Fin d√©fi {message_id}")
    except Exception as e:
        print(f"‚ùå Erreur dans retirer_role_apres_defi: {e}")

@tree.command(name="defi_semaine", description="Lance un d√©fi hebdomadaire (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def defi_semaine(interaction: discord.Interaction, salon: discord.TextChannel, role: discord.Role, duree_heures: int, recurrence: bool, start_date: Optional[str] = None, challenge_message: Optional[str] = None):
    if duree_heures <= 0 or duree_heures > 10000:
        await interaction.response.send_message("‚ùå Dur√©e invalide.", ephemeral=True)
        return
    if recurrence:
        if not start_date or not challenge_message:
            await interaction.response.send_message("‚ùå Fournissez start_date et challenge_message.", ephemeral=True)
            return
        try:
            datetime.datetime.strptime(start_date, "%d/%m/%Y %H:%M")
        except ValueError:
            await interaction.response.send_message("‚ùå Format start_date invalide.", ephemeral=True)
            return
        msg_id = str(uuid.uuid4())
        messages_programmes[msg_id] = {
            "channel_id": str(salon.id),
            "message": challenge_message,
            "type": "weekly_challenge",
            "next": start_date,
            "role_id": str(role.id),
            "duration_hours": str(duree_heures)
        }
        await sauvegarder_json_async(MSG_FILE, messages_programmes)
        await interaction.response.send_message(f"‚úÖ D√©fi r√©current programm√© dans {salon.mention} √† partir du {start_date}.", ephemeral=True)
    else:
        try:
            await interaction.response.send_modal(DefiModal(salon, role, duree_heures))
        except Exception as e:
            if not interaction.response.is_done():
                await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)
            else:
                await interaction.followup.send(f"‚ùå Erreur: {e}", ephemeral=True)

# ------------------------------------------
# Envoi de message via modal (admin)
# ------------------------------------------
class ModalEnvoyerMessage(Modal, title="üì© Envoyer un message"):
    def __init__(self, salon: discord.TextChannel):
        super().__init__(timeout=None)
        self.salon = salon
        self.contenu = TextInput(
            label="Message",
            style=TextStyle.paragraph,
            placeholder="Tapez votre message",
            required=True,
            max_length=2000
        )
        self.add_item(self.contenu)
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        try:
            await self.salon.send(textwrap.dedent(self.contenu.value))
            await interaction.followup.send(f"‚úÖ Message envoy√© dans {self.salon.mention}.", ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"‚ùå Erreur: {e}", ephemeral=True)

@tree.command(name="envoyer_message", description="Envoie un message via le bot (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def envoyer_message(interaction: discord.Interaction, salon: discord.TextChannel):
    try:
        await interaction.response.send_modal(ModalEnvoyerMessage(salon))
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)

# ------------------------------------------
# Commande /clear (admin)
# ------------------------------------------
@tree.command(name="clear", description="Supprime jusqu'√† 100 messages (admin)")
@app_commands.checks.has_permissions(manage_messages=True)
async def clear(interaction: discord.Interaction, nombre: int):
    if not (1 <= nombre <= 100):
        await interaction.response.send_message("‚ùå Choisissez entre 1 et 100.", ephemeral=True)
        return
    try:
        await interaction.response.defer(ephemeral=True)
        deleted = await interaction.channel.purge(limit=nombre)
        await interaction.followup.send(f"üßΩ {len(deleted)} messages supprim√©s.", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)

# ------------------------------------------
# Vues de confirmation pour suppression
# ------------------------------------------
class ConfirmDeleteRolesView(View):
    def __init__(self, interaction: discord.Interaction):
        super().__init__(timeout=60)
        self.interaction = interaction
    @discord.ui.button(label="Oui", style=discord.ButtonStyle.danger)
    async def confirm(self, interaction: discord.Interaction, button: Button):
        if interaction.user != self.interaction.user:
            await interaction.response.send_message("‚ùå Autoris√© uniquement pour l'admin init.", ephemeral=True)
            return
        await interaction.response.edit_message(content="Suppression en cours...", view=None)
        errors = []
        guild = interaction.guild
        for role in guild.roles:
            if not role.permissions.administrator and (role < guild.me.top_role):
                try:
                    await role.delete(reason="Demand√© par admin")
                    await asyncio.sleep(0.5)
                except Exception as e:
                    errors.append(f"{role.name}: {e}")
        if errors:
            await interaction.followup.send("Certains r√¥les n'ont pas pu √™tre supprim√©s:\n" + "\n".join(errors), ephemeral=True)
        else:
            await interaction.followup.send("‚úÖ R√¥les supprim√©s.", ephemeral=True)
        self.stop()
    @discord.ui.button(label="Non", style=discord.ButtonStyle.secondary)
    async def cancel(self, interaction: discord.Interaction, button: Button):
        await interaction.response.edit_message(content="Op√©ration annul√©e.", view=None)
        self.stop()

class ConfirmDeleteChannelsView(View):
    def __init__(self, interaction: discord.Interaction):
        super().__init__(timeout=60)
        self.interaction = interaction
    @discord.ui.button(label="Oui", style=discord.ButtonStyle.danger)
    async def confirm(self, interaction: discord.Interaction, button: Button):
        if interaction.user != self.interaction.user:
            await interaction.response.send_message("‚ùå Autoris√© uniquement pour l'admin init.", ephemeral=True)
            return
        await interaction.response.edit_message(content="Suppression en cours...", view=None)
        errors = []
        for channel in interaction.guild.channels:
            try:
                await channel.delete(reason="Demand√© par admin")
                await asyncio.sleep(0.5)
            except Exception as e:
                errors.append(f"{channel.name}: {e}")
        if errors:
            await interaction.followup.send("Certains salons/cat√©gories n'ont pas pu √™tre supprim√©s:\n" + "\n".join(errors), ephemeral=True)
        else:
            await interaction.followup.send("‚úÖ Salons et cat√©gories supprim√©s.", ephemeral=True)
        self.stop()
    @discord.ui.button(label="Non", style=discord.ButtonStyle.secondary)
    async def cancel(self, interaction: discord.Interaction, button: Button):
        await interaction.response.edit_message(content="Op√©ration annul√©e.", view=None)
        self.stop()

# ------------------------------------------
# Cog d'administration avanc√©e
# ------------------------------------------
class AdminUtilsCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot
    @app_commands.command(name="supprimer_categorie", description="Supprime une cat√©gorie (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def supprimer_categorie(self, interaction: discord.Interaction, categorie: discord.CategoryChannel):
        try:
            await categorie.delete()
            await interaction.response.send_message(f"‚úÖ Cat√©gorie **{categorie.name}** supprim√©e.", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)
    @app_commands.command(name="supprimer_salon", description="Supprime un salon (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def supprimer_salon(self, interaction: discord.Interaction, salon: discord.abc.GuildChannel):
        try:
            await salon.delete()
            await interaction.response.send_message(f"‚úÖ Salon **{salon.name}** supprim√©.", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)
    @app_commands.command(name="reset_roles", description="Retire tous les r√¥les (sauf admin) de tous les membres (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def reset_roles(self, interaction: discord.Interaction):
        try:
            for member in interaction.guild.members:
                roles_to_remove = [r for r in member.roles if not r.permissions.administrator]
                if roles_to_remove:
                    await member.remove_roles(*roles_to_remove, reason="R√©initialisation")
            await interaction.response.send_message("‚úÖ R√¥les r√©initialis√©s.", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)
    @app_commands.command(name="supprimer_tous_roles", description="Supprime tous les r√¥les non-admin (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def supprimer_tous_roles(self, interaction: discord.Interaction):
        view = ConfirmDeleteRolesView(interaction)
        await interaction.response.send_message("Confirmez la suppression de tous les r√¥les non-admin.", view=view, ephemeral=True)
    @app_commands.command(name="supprimer_tous_salons_categories", description="Supprime tous les salons et cat√©gories (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def supprimer_tous_salons_categories(self, interaction: discord.Interaction):
        view = ConfirmDeleteChannelsView(interaction)
        await interaction.response.send_message("Confirmez la suppression de tous les salons et cat√©gories.", view=view, ephemeral=True)

async def setup_admin_utils(bot: commands.Bot):
    await bot.add_cog(AdminUtilsCog(bot))

# ------------------------------------------
# Module AutoDM (admin)
# ------------------------------------------
class AutoDMCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.auto_dm_configs = {}
    async def load_configs(self):
        configs = await charger_json_async(AUTO_DM_FILE)
        if not isinstance(configs, dict):
            configs = {}
        self.auto_dm_configs = configs
        print("‚öôÔ∏è Configurations AutoDM charg√©es.")
    async def save_configs(self):
        await sauvegarder_json_async(AUTO_DM_FILE, self.auto_dm_configs)
        print("‚öôÔ∏è Config AutoDM sauvegard√©e.")
    async def cog_load(self):
        await self.load_configs()
    @app_commands.command(name="autodm_add", description="Ajoute une config AutoDM (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def autodm_add(self, interaction: discord.Interaction, role: discord.Role, dm_message: str):
        if not dm_message.strip():
            await interaction.response.send_message("‚ùå Message DM vide.", ephemeral=True)
            return
        config_id = str(uuid.uuid4())
        self.auto_dm_configs[config_id] = {"role_id": str(role.id), "dm_message": dm_message.strip()}
        await self.save_configs()
        await interaction.response.send_message(f"‚úÖ Config ajout√©e avec l'ID `{config_id}`.", ephemeral=True)
    @app_commands.command(name="autodm_list", description="Liste les configs AutoDM (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def autodm_list(self, interaction: discord.Interaction):
        if not self.auto_dm_configs:
            await interaction.response.send_message("Aucune config AutoDM.", ephemeral=True)
            return
        lines = []
        for cid, config in self.auto_dm_configs.items():
            role_obj = interaction.guild.get_role(int(config.get("role_id", 0)))
            role_name = role_obj.name if role_obj else f"ID {config.get('role_id')}"
            lines.append(f"ID: `{cid}`\nR√¥le: {role_name}\nMessage: {config.get('dm_message')}\n")
        await interaction.response.send_message("\n".join(lines), ephemeral=True)
    @app_commands.command(name="autodm_remove", description="Supprime une config AutoDM (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def autodm_remove(self, interaction: discord.Interaction, config_id: str):
        if config_id in self.auto_dm_configs:
            del self.auto_dm_configs[config_id]
            await self.save_configs()
            await interaction.response.send_message(f"‚úÖ Config `{config_id}` supprim√©e.", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå ID non trouv√©.", ephemeral=True)
    @app_commands.command(name="autodm_modify", description="Modifie une config AutoDM (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def autodm_modify(self, interaction: discord.Interaction, config_id: str, new_role: Optional[discord.Role] = None, new_dm_message: Optional[str] = None):
        if config_id not in self.auto_dm_configs:
            await interaction.response.send_message("‚ùå ID non trouv√©.", ephemeral=True)
            return
        config = self.auto_dm_configs[config_id]
        if new_role is not None:
            config["role_id"] = str(new_role.id)
        if new_dm_message is not None:
            if not new_dm_message.strip():
                await interaction.response.send_message("‚ùå Nouveau message vide.", ephemeral=True)
                return
            config["dm_message"] = new_dm_message.strip()
        self.auto_dm_configs[config_id] = config
        await self.save_configs()
        await interaction.response.send_message(f"‚úÖ Config `{config_id}` modifi√©e.", ephemeral=True)

async def setup_autodm(bot: commands.Bot):
    await bot.add_cog(AutoDMCog(bot))

# ------------------------------------------
# Module de mod√©ration (admin)
# ------------------------------------------
class ModerationCog(commands.Cog):
    def __init__(self, bot: commands.Bot):
        self.bot = bot
        self.banned_words = {"merde", "putain", "con", "connard", "salop", "encul√©", "nique ta m√®re"}
    @app_commands.command(name="list_banned_words", description="Liste des mots bannis (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def list_banned_words(self, interaction: discord.Interaction):
        await interaction.response.send_message(f"Mots bannis: {', '.join(sorted(self.banned_words))}", ephemeral=True)
    @app_commands.command(name="add_banned_word", description="Ajoute un mot √† bannir (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def add_banned_word(self, interaction: discord.Interaction, word: str):
        word_low = word.lower()
        if word_low in self.banned_words:
            await interaction.response.send_message("Ce mot est d√©j√† banni.", ephemeral=True)
        else:
            self.banned_words.add(word_low)
            await interaction.response.send_message(f"Le mot '{word}' a √©t√© ajout√©.", ephemeral=True)
    @app_commands.command(name="remove_banned_word", description="Retire un mot de la liste (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def remove_banned_word(self, interaction: discord.Interaction, word: str):
        word_low = word.lower()
        if word_low in self.banned_words:
            self.banned_words.remove(word_low)
            await interaction.response.send_message(f"Le mot '{word}' n'est plus banni.", ephemeral=True)
        else:
            await interaction.response.send_message("Ce mot n'√©tait pas banni.", ephemeral=True)
    @app_commands.command(name="mute", description="Mute un utilisateur (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def mute(self, interaction: discord.Interaction, member: discord.Member, duration: int):
        muted_role = discord.utils.get(interaction.guild.roles, name="Muted")
        if not muted_role:
            try:
                muted_role = await interaction.guild.create_role(name="Muted", reason="Cr√©ation pour mute")
                for channel in interaction.guild.channels:
                    await channel.set_permissions(muted_role, send_messages=False, speak=False)
            except Exception as e:
                await interaction.response.send_message(f"‚ùå Erreur cr√©ation r√¥le: {e}", ephemeral=True)
                return
        try:
            await member.add_roles(muted_role, reason="Mute admin")
            await interaction.response.send_message(f"{member.mention} mut√© pendant {duration} minutes.", ephemeral=True)
            await asyncio.sleep(duration * 60)
            await member.remove_roles(muted_role, reason="Fin du mute")
            await interaction.followup.send(f"{member.mention} n'est plus mute.", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Erreur lors du mute: {e}", ephemeral=True)
    @app_commands.command(name="ban", description="Bannit un utilisateur (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def ban(self, interaction: discord.Interaction, member: discord.Member, reason: str = "Aucune raison"):
        try:
            await member.ban(reason=reason)
            await interaction.response.send_message(f"{member.mention} banni. Raison: {reason}", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Erreur banning: {e}", ephemeral=True)
    @app_commands.command(name="kick", description="Expulse un utilisateur (admin)")
    @app_commands.checks.has_permissions(administrator=True)
    async def kick(self, interaction: discord.Interaction, member: discord.Member, reason: str = "Aucune raison"):
        try:
            await member.kick(reason=reason)
            await interaction.response.send_message(f"{member.mention} expuls√©. Raison: {reason}", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Erreur kick: {e}", ephemeral=True)

async def setup_moderation(bot: commands.Bot):
    await bot.add_cog(ModerationCog(bot))

# ------------------------------------------
# Serveur HTTP keep-alive
# ------------------------------------------
class KeepAliveHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b'Bot actif.')
    def log_message(self, format, *args):
        return

def keep_alive(port=10000):
    try:
        server = HTTPServer(('0.0.0.0', port), KeepAliveHandler)
        thread = threading.Thread(target=server.serve_forever, name="KeepAliveThread")
        thread.daemon = True
        thread.start()
        print(f"‚úÖ Serveur keep-alive sur le port {port}")
    except Exception as e:
        print(f"‚ùå Erreur keep-alive: {e}")

keep_alive()

@bot.event
async def on_ready():
    try:
        print(f"‚úÖ Connect√© en tant que {bot.user} (ID: {bot.user.id})")
    except Exception as e:
        print(f"‚ùå Erreur on_ready: {e}")

# ------------------------------------------
# Commande Pomodoro
# ------------------------------------------
@tree.command(name="pomodoro", description="Lance une session Pomodoro personnalis√©e")
@app_commands.describe(focus="Temps focus (min)", pause="Pause courte (min)", longue_pause="Pause longue (min)")
async def pomodoro(interaction: discord.Interaction, focus: int = 25, pause: int = 5, longue_pause: int = 10):
    await interaction.response.defer(ephemeral=True)
    allowed_id = config_pomodoro.get("allowed_channel_id")
    if allowed_id and str(interaction.channel.id) != allowed_id:
        await interaction.followup.send("‚ùå Cette commande n'est pas autoris√©e ici.", ephemeral=True)
        return
    await interaction.followup.send(f"üïí D√©but de session Pomodoro : {focus} min focus, {pause} min pause, {longue_pause} min pause longue.", ephemeral=True)
    user = interaction.user
    try:
        # On envoie les instructions par DM pour ne pas bloquer le canal
        for session in range(1, 5):
            await user.send(f"üî¥ Session {session} ‚Äî Focus pendant {focus} minutes.")
            await asyncio.sleep(focus * 60)
            if session < 4:
                await user.send(f"üü° Pause courte de {pause} minutes.")
                await asyncio.sleep(pause * 60)
            else:
                await user.send(f"üü¢ Pause longue de {longue_pause} minutes.")
                await asyncio.sleep(longue_pause * 60)
        await user.send("‚úÖ Pomodoro termin√© !")
    except Exception as e:
        await interaction.followup.send(f"‚ùå Erreur en DM: {e}", ephemeral=True)

# ------------------------------------------
# Module d'objectifs personnels
# ------------------------------------------
@tree.command(name="ajouter_objectif", description="Ajoute un objectif personnel")
async def ajouter_objectif(interaction: discord.Interaction, objectif: str):
    if bot.xp_config.get("goals_channel") and str(interaction.channel.id) != str(bot.xp_config["goals_channel"]):
        await interaction.response.send_message("‚ùå Commande non autoris√©e ici.", ephemeral=True)
        return
    uid = str(interaction.user.id)
    objectifs_data.setdefault(uid, []).append(objectif)
    await sauvegarder_json_async(GOALS_FILE, objectifs_data)
    await interaction.response.send_message(f"‚úÖ Objectif ajout√© : **{objectif}**", ephemeral=True)

@tree.command(name="voir_objectifs", description="Affiche tes objectifs")
async def voir_objectifs(interaction: discord.Interaction):
    if bot.xp_config.get("goals_channel") and str(interaction.channel.id) != str(bot.xp_config["goals_channel"]):
        await interaction.response.send_message("‚ùå Commande non autoris√©e ici.", ephemeral=True)
        return
    uid = str(interaction.user.id)
    objectifs = objectifs_data.get(uid, [])
    if not objectifs:
        await interaction.response.send_message("üì≠ Aucun objectif.", ephemeral=True)
        return
    txt = "\n".join(f"üîπ {o}" for o in objectifs)
    await interaction.response.send_message(f"üéØ Objectifs:\n{txt}", ephemeral=True)

@tree.command(name="supprimer_objectif", description="Supprime un de tes objectifs")
@app_commands.describe(position="Num√©ro de l'objectif (1 pour le premier)")
async def supprimer_objectif(interaction: discord.Interaction, position: int):
    if bot.xp_config.get("goals_channel") and str(interaction.channel.id) != str(bot.xp_config["goals_channel"]):
        await interaction.response.send_message("‚ùå Commande non autoris√©e ici.", ephemeral=True)
        return
    uid = str(interaction.user.id)
    objectifs = objectifs_data.get(uid, [])
    if not (1 <= position <= len(objectifs)):
        await interaction.response.send_message("‚ùå Num√©ro invalide.", ephemeral=True)
        return
    suppr = objectifs.pop(position - 1)
    if not objectifs:
        objectifs_data.pop(uid, None)
    await sauvegarder_json_async(GOALS_FILE, objectifs_data)
    await interaction.response.send_message(f"üóëÔ∏è Objectif supprim√©: **{suppr}**", ephemeral=True)

# ------------------------------------------
# R√©capitulatif et statistiques hebdomadaires
# ------------------------------------------
@tree.command(name="set_channel_recap", description="D√©finit le salon pour les r√©cap hebdo (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def set_channel_recap(interaction: discord.Interaction, channel: discord.TextChannel):
    bot.recap_config["channel_id"] = str(channel.id)
    await interaction.response.send_message(f"‚úÖ Salon r√©cap d√©fini: {channel.mention}", ephemeral=True)

@tree.command(name="set_role_recap", description="D√©finit le r√¥le √† mentionner pour le r√©cap (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def set_role_recap(interaction: discord.Interaction, role: discord.Role):
    bot.recap_config["role_id"] = str(role.id)
    await interaction.response.send_message(f"‚úÖ R√¥le r√©cap d√©fini: {role.mention}", ephemeral=True)

@tasks.loop(minutes=1)
async def recap_hebdo_task():
    try:
        now = datetime.datetime.now(ZoneInfo("Europe/Paris"))
        if now.weekday() == 6 and now.hour == 20 and now.minute == 0:
            chan_id = bot.recap_config.get("channel_id")
            role_id = bot.recap_config.get("role_id")
            if chan_id and role_id:
                channel = bot.get_channel(int(chan_id))
                if channel:
                    msg = f"üìÜ **R√©capitulatif hebdomadaire !**\n<@&{role_id}> partagez vos avanc√©es pour la semaine √† venir."
                    await channel.send(msg)
                    print("‚úÖ R√©cap envoy√©.")
                else:
                    print("‚ùå Salon r√©cap introuvable.")
    except Exception as e:
        print(f"‚ùå Erreur dans recap_hebdo_task: {e}")

@tasks.loop(minutes=1)
async def weekly_stats_task():
    try:
        now = datetime.datetime.now(ZoneInfo("Europe/Paris"))
        if now.weekday() == 6 and now.hour == 21 and now.minute == 0:
            if not hasattr(bot, "stats_channel_id") or not bot.stats_channel_id:
                print("‚ö†Ô∏è Pas de salon stats d√©fini.")
                return
            channel = bot.get_channel(int(bot.stats_channel_id))
            if not channel:
                print("‚ùå Salon stats introuvable.")
                return
            if not bot.weekly_stats:
                await channel.send("üìä Aucune activit√© cette semaine.")
                return
            stats_msg = "**üìà Stat hebdomadaire :**\n"
            for uid, data in bot.weekly_stats.items():
                member = channel.guild.get_member(int(uid))
                if not member: continue
                msg_count = data.get("messages", 0)
                minutes_vocal = round(data.get("vocal", 0) / 60)
                stats_msg += f"‚Ä¢ {member.mention} ‚Äî {msg_count} msg / {minutes_vocal} min vocal\n"
            await channel.send(stats_msg)
            bot.weekly_stats = {}
            print("‚úÖ Stats hebdomadaires envoy√©es.")
    except Exception as e:
        print(f"‚ùå Erreur dans weekly_stats_task: {e}")

@tree.command(name="stats_hebdo", description="Affiche tes stats hebdomadaires")
async def stats_hebdo(interaction: discord.Interaction):
    try:
        uid = str(interaction.user.id)
        stats = bot.weekly_stats.get(uid, {"messages": 0, "vocal": 0})
        msg = stats.get("messages", 0)
        min_vocal = round(stats.get("vocal", 0) / 60)
        texte = f"üìä **Stats de la semaine ‚Äî {interaction.user.mention}**\n‚úâÔ∏è Messages: {msg}\nüéôÔ∏è Vocal: {min_vocal} min"
        await interaction.response.send_message(texte, ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)

# ------------------------------------------
# Alertes SOS
# ------------------------------------------
@tree.command(name="set_destinataires_sos", description="Configure alertes SOS (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def set_destinataires_sos(interaction: discord.Interaction, mentions_roles: str, mentions_utilisateurs: str):
    bot.sos_receivers = []
    for role in interaction.guild.roles:
        if role.mention in mentions_roles:
            bot.sos_receivers.append(role.id)
    for member in interaction.guild.members:
        if member.mention in mentions_utilisateurs:
            bot.sos_receivers.append(member.id)
    await sauvegarder_json_async(SOS_CONFIG_FILE, {"receivers": bot.sos_receivers})
    await interaction.response.send_message("‚úÖ Destinataires SOS configur√©s.", ephemeral=True)

@tree.command(name="sos", description="Lance une alerte SOS")
async def sos(interaction: discord.Interaction):
    await interaction.response.defer(ephemeral=True)
    try:
        if not bot.sos_receivers:
            await interaction.followup.send("‚ö†Ô∏è Aucun destinataire SOS configur√©.", ephemeral=True)
            return
        for rec in bot.sos_receivers:
            member = interaction.guild.get_member(rec)
            if member:
                try:
                    await member.send(f"üö® SOS: {interaction.user.mention} a besoin d'aide.")
                except Exception:
                    pass
        await interaction.followup.send("‚úÖ Alerte SOS envoy√©e.", ephemeral=True)
    except Exception as e:
        await interaction.followup.send(f"‚ùå Erreur: {e}", ephemeral=True)

# ------------------------------------------
# Modes √©v√©nementiels et th√®mes
# ------------------------------------------
@tree.command(name="mode_evenement", description="Active/d√©sactive un mode √©v√©nement (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def mode_evenement(interaction: discord.Interaction, nom: str, message: str, actif: bool):
    try:
        bot.evenement_config.update({"actif": actif, "nom": nom, "message": message})
        await sauvegarder_json_async(EVENEMENT_CONFIG_FILE, bot.evenement_config)
        if actif:
            await interaction.response.send_message(f"üéâ Mode √©v√©nement '{nom}' activ√©: {message}", ephemeral=True)
        else:
            await interaction.response.send_message("‚úÖ Mode √©v√©nement d√©sactiv√©.", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)

@tree.command(name="set_theme", description="D√©finit un th√®me visuel (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def set_theme(interaction: discord.Interaction, nom: str, emoji: str, message: str):
    try:
        bot.theme_config.update({"nom": nom, "emoji": emoji, "message": message})
        await sauvegarder_json_async(THEME_CONFIG_FILE, bot.theme_config)
        await interaction.response.send_message(f"üé® Th√®me '{nom}' d√©fini avec {emoji}: {message}", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)

# ------------------------------------------
# Missions secr√®tes
# ------------------------------------------
@tree.command(name="mission_secrete", description="Assigne une mission secr√®te (admin)")
@app_commands.checks.has_permissions(administrator=True)
async def mission_secrete(interaction: discord.Interaction, utilisateur: discord.Member, mission: str):
    try:
        bot.missions_secretes[str(utilisateur.id)] = {
            "mission": mission,
            "assign√©e_par": interaction.user.id,
            "timestamp": datetime.datetime.now().isoformat()
        }
        await sauvegarder_json_async(MISSIONS_FILE, bot.missions_secretes)
        try:
            await utilisateur.send(f"üïµÔ∏è Mission secr√®te: {mission}")
        except Exception:
            pass
        await interaction.response.send_message(f"‚úÖ Mission attribu√©e √† {utilisateur.mention}.", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)

@tree.command(name="ma_mission", description="Affiche ta mission secr√®te")
async def ma_mission(interaction: discord.Interaction):
    data = bot.missions_secretes.get(str(interaction.user.id))
    if data:
        await interaction.response.send_message(f"üïµÔ∏è Mission: {data['mission']}", ephemeral=True)
    else:
        await interaction.response.send_message("‚ùå Aucune mission assign√©e.", ephemeral=True)

# ------------------------------------------
# √âv√©nements sur calendrier collaboratif
# ------------------------------------------
@tree.command(name="ajouter_evenement", description="Ajoute un √©v√©nement au calendrier")
@app_commands.describe(titre="Titre", date="JJ/MM/AAAA", heure="HH:MM", description="Description")
async def ajouter_evenement(interaction: discord.Interaction, titre: str, date: str, heure: str, description: str):
    try:
        dt = datetime.datetime.strptime(f"{date} {heure}", "%d/%m/%Y %H:%M")
        eid = str(uuid.uuid4())
        bot.evenements_calendrier[eid] = {
            "auteur": interaction.user.id,
            "titre": titre,
            "datetime": dt.isoformat(),
            "description": description
        }
        await sauvegarder_json_async(CALENDRIER_FILE, bot.evenements_calendrier)
        await interaction.response.send_message(f"‚úÖ √âv√©nement '{titre}' ajout√©.", ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)

@tree.command(name="voir_evenements", description="Affiche les √©v√©nements √† venir")
async def voir_evenements(interaction: discord.Interaction):
    try:
        if not bot.evenements_calendrier:
            await interaction.response.send_message("üì≠ Aucun √©v√©nement pr√©vu.", ephemeral=True)
            return
        now = datetime.datetime.now()
        events = []
        for eid, evt in sorted(bot.evenements_calendrier.items(), key=lambda x: x[1]["datetime"]):
            dt = datetime.datetime.fromisoformat(evt["datetime"])
            if dt > now:
                events.append(f"üìÖ **{evt['titre']}** le {dt.strftime('%d/%m/%Y √† %H:%M')}\nüìù {evt['description']}")
        msg = "\n\n".join(events) if events else "üì≠ Aucun √©v√©nement √† venir."
        await interaction.response.send_message(msg, ephemeral=True)
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)

# ------------------------------------------
# Syst√®me de demande d'aide ‚Äì Version am√©lior√©e
# ------------------------------------------
class HelpRequestModal(Modal, title="üì© Demande d'aide"):
    def __init__(self):
        super().__init__(timeout=None)
        self.probleme = TextInput(
            label="D√©cris ton probl√®me :",
            style=TextStyle.paragraph,
            placeholder="Exemple: Je bloque sur ...",
            required=True,
            max_length=2000
        )
        self.add_item(self.probleme)
    async def on_submit(self, interaction: discord.Interaction):
        await interaction.response.defer(ephemeral=True)
        try:
            desc = self.probleme.value
            guild = interaction.guild
            # Cr√©ation en arri√®re-plan du salon priv√© (accessible uniquement au demandeur)
            category = await guild.create_category(f"Aide - {interaction.user.display_name}")
            text_chan = await guild.create_text_channel("aide-priv√©e", category=category)
            voice_chan = await guild.create_voice_channel("aide-priv√©e", category=category)
            await category.set_permissions(guild.default_role, view_channel=False)
            await category.set_permissions(interaction.user, view_channel=True)
            # Sauvegarde de la demande
            data = {
                "user_id": str(interaction.user.id),
                "description": desc,
                "category_id": str(category.id),
                "text_channel_id": str(text_chan.id),
                "voice_channel_id": str(voice_chan.id),
                "created_at": datetime.datetime.now().isoformat()
            }
            categories_aide[str(interaction.user.id)] = data
            await sauvegarder_json_async(HELP_REQUEST_FILE, categories_aide)
            # Publication d'un message public dans le salon de commande
            public_msg = (f"üö® **Demande d'aide** üö®\n"
                          f"{interaction.user.mention} a besoin d'aide :\n>>> {desc}\n"
                          f"Cliquez sur le bouton ci-dessous pour acc√©der au salon priv√© d'aide.")
            await interaction.channel.send(public_msg, view=HelpButtons(interaction.user.id))
            await interaction.followup.send("‚úÖ Demande d'aide cr√©√©e. Consultez le message public pour acc√©der au salon.", ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"‚ùå Erreur lors de la demande d'aide: {e}", ephemeral=True)

class HelpButtons(View):
    def __init__(self, requester_id: int):
        super().__init__()
        self.requester_id = requester_id
    @discord.ui.button(label="Je peux aider", style=discord.ButtonStyle.primary)
    async def aider(self, interaction: discord.Interaction, button: Button):
        req = categories_aide.get(str(self.requester_id))
        if not req:
            await interaction.response.send_message("Cette demande d'aide n'existe plus.", ephemeral=True)
            return
        category = interaction.guild.get_category(int(req["category_id"]))
        if not category:
            await interaction.response.send_message("Salon d'aide introuvable.", ephemeral=True)
            return
        role = discord.utils.get(interaction.guild.roles, name="Aider")
        if not role:
            role = await interaction.guild.create_role(name="Aider")
        await interaction.user.add_roles(role)
        await category.set_permissions(role, view_channel=True)
        await interaction.response.send_message("üîî Vous avez acc√®s au salon priv√© d'aide.", ephemeral=True)
    @discord.ui.button(label="Probl√®me R√©solu", style=discord.ButtonStyle.danger)
    async def resoudre(self, interaction: discord.Interaction, button: Button):
        if interaction.user.id != self.requester_id:
            await interaction.response.send_message("‚ùå Seul le demandeur peut clore la demande.", ephemeral=True)
            return
        req = categories_aide.get(str(self.requester_id))
        if req:
            category = interaction.guild.get_category(int(req["category_id"]))
            if category:
                await category.delete()
            del categories_aide[str(self.requester_id)]
            await sauvegarder_json_async(HELP_REQUEST_FILE, categories_aide)
        await interaction.response.send_message("‚úÖ Demande d'aide ferm√©e.", ephemeral=True)

@tree.command(name="besoin_aide", description="Cr√©e une demande d'aide")
async def besoin_aide(interaction: discord.Interaction):
    try:
        await interaction.response.send_modal(HelpRequestModal())
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)

# ------------------------------------------
# Journal de focus ‚Äì Modifications pour √©viter le blocage et utiliser followup
# ------------------------------------------
@tree.command(name="journal_focus", description="Enregistre ton journal de focus")
async def journal_focus(interaction: discord.Interaction, texte: str):
    # Si un salon sp√©cifique est d√©fini, la commande doit √™tre utilis√©e dans celui-ci
    if bot.journal_focus_channel and str(interaction.channel.id) != bot.journal_focus_channel:
        await interaction.response.send_message("‚ùå Cette commande n'est pas autoris√©e ici.", ephemeral=True)
        return
    await interaction.response.defer(ephemeral=True)
    try:
        # Utilisation de followup pour s'assurer que la r√©ponse est envoy√©e sans d√©lai
        await interaction.followup.send("‚úÖ Journal enregistr√©.", ephemeral=True)
        # Envoi public du journal dans le m√™me salon
        await interaction.followup.send(f"üìù Journal de {interaction.user.mention} :\n```{texte}```")
    except Exception as e:
        await interaction.followup.send(f"‚ùå Erreur: {e}", ephemeral=True)

# ------------------------------------------
# Syst√®me de r√©actions multi r√¥le avec message
# ------------------------------------------
@tree.command(name="reaction_role_avec_message", description="Cr√©e un message avec r√©actions pour attribuer des r√¥les")
@app_commands.checks.has_permissions(administrator=True)
async def reaction_role_avec_message(interaction: discord.Interaction, salon: discord.TextChannel, emojis: str, roles: str):
    try:
        emojis_list = [e.strip() for e in emojis.split(",")]
        roles_list = [r.strip() for r in roles.split(",")]
        if len(emojis_list) != len(roles_list):
            await interaction.response.send_message("‚ùå Le nombre d'emojis et de r√¥les doit correspondre.", ephemeral=True)
            return
        bot.temp_data["reaction_role"] = {
            "channel": salon,
            "emojis": emojis_list,
            "roles": roles_list,
            "user_id": interaction.user.id
        }
        class ModalReactionRole(Modal, title="Message avec r√©actions"):
            message = TextInput(
                label="Texte du message",
                style=TextStyle.paragraph,
                required=True,
                max_length=4000
            )
            async def on_submit(self, interaction_modal: discord.Interaction):
                await interaction_modal.response.defer(ephemeral=True)
                data = bot.temp_data.get("reaction_role", {})
                if interaction_modal.user.id != data.get("user_id"):
                    await interaction_modal.followup.send("‚ùå Vous n'√™tes pas autoris√©.", ephemeral=True)
                    return
                channel = data.get("channel")
                emojis = data.get("emojis")
                roles_str = data.get("roles")
                txt = self.message.value
                sent_msg = await channel.send(txt)
                for emo in emojis:
                    await sent_msg.add_reaction(emo)
                mapping = {}
                for emo, role_str in zip(emojis, roles_str):
                    key = get_emoji_key(emo)
                    # Recherche du r√¥le
                    if role_str.startswith("<@&"):
                        role_id = int(role_str.replace("<@&", "").replace(">", ""))
                    else:
                        r_obj = discord.utils.get(interaction.guild.roles, name=role_str.replace("@", ""))
                        if r_obj:
                            role_id = r_obj.id
                        else:
                            await interaction_modal.followup.send(f"‚ùå R√¥le non trouv√©: {role_str}", ephemeral=True)
                            return
                    mapping[key] = role_id
                bot.reaction_roles[str(sent_msg.id)] = mapping
                await sauvegarder_json_async(REACTION_ROLE_FILE, bot.reaction_roles)
                await interaction_modal.followup.send("‚úÖ Message envoy√© et r√©actions enregistr√©es!", ephemeral=True)
        await interaction.response.send_modal(ModalReactionRole())
    except Exception as e:
        await interaction.response.send_message(f"‚ùå Erreur: {e}", ephemeral=True)

# ------------------------------------------
# Fonction main ‚Äì Chargement des donn√©es et lancement
# ------------------------------------------
async def main():
    global xp_data, messages_programmes, defis_data, config_pomodoro, objectifs_data, categories_aide
    try:
        xp_data = await charger_json_async(XP_FILE)
        messages_programmes = await charger_json_async(MSG_FILE)
        defis_data = await charger_json_async(DEFIS_FILE)
        config_pomodoro = await charger_json_async(POMODORO_CONFIG_FILE)
        objectifs_data = await charger_json_async(GOALS_FILE)
        bot.evenement_config = await charger_json_async(EVENEMENT_CONFIG_FILE)
        bot.theme_config = await charger_json_async(THEME_CONFIG_FILE)
        bot.missions_secretes = await charger_json_async(MISSIONS_FILE)
        bot.evenements_calendrier = await charger_json_async(CALENDRIER_FILE)
        categories_aide = await charger_json_async(HELP_REQUEST_FILE)
        bot.reaction_roles = await charger_json_async(REACTION_ROLE_FILE)
        sos_conf = await charger_json_async(SOS_CONFIG_FILE)
        bot.sos_receivers = sos_conf.get("receivers", [])
        print("‚öôÔ∏è Donn√©es charg√©es.")
    except Exception as e:
        print(f"‚ùå Erreur chargement donn√©es: {e}")
    await setup_admin_utils(bot)
    await setup_autodm(bot)
    await setup_moderation(bot)
    try:
        token = os.getenv("DISCORD_TOKEN")
        if not token:
            print("‚ùå DISCORD_TOKEN non d√©fini")
            return
        await bot.start(token)
    except Exception as e:
        print(f"‚ùå Erreur critique lancement bot: {e}")

if __name__ == "__main__":
    asyncio.run(main())
